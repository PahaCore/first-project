# Практика - шпаргалки по командам 

## Настройка
```
git config --global user.name user
git config --global user.email user@mail.ru
```
## Посмотреть настройки git
```
git config --list
```
## Сделать папку репозиторием
```
git init
```
## Посмотреть в каком состоянии репозиторий
```
git status
```
## Подготовить к сохранению сразу все файлы
```
git add --all
```
## Добавить в репозиторий текущую папку со всеми файлами
```
git add .
```
## Сделать коммит
```
git commit -m "Описание коммита"
```
## Сокращённый лог
```
git log --oneline
```
## Проверить что ssh доступ работает
```
ssh -T git@github.com
```
## Привязать удалённый репозиторий к локальному
```
git remote add origin git@github.com:User/project.git
```
## Убедиться, что репозитории связаны
```
git remote -v
```
## Синхронизировать локальный и удалённый репозиторий
```
git push -u origin main
```
## Отправить изменения на удалённый репозиторий
```
git push
```
## Исправить последний коммит
```
git commit --amend --no-edit
```
## Исправить последний коммит и изменить описание к нему
```
git commit --amend -m "Новое сообщение"
```
## Откатить изменения, которые не попали ни в staging, ни в коммит
```
git restore example.txt
```
## Откатить изменения, которые попали в staging и в коммит
```
git restore --staged example.txt
```
## Вернуть состояние репозитория к более раннему состоянию “b576d89” - хэш коммита до которого всё будет удалено
```
git reset --hard b576d89
```
## Сравнить последнюю закоммиченную версию файла с той, что находится в состоянии modified
```
git diff
```
## Показать изменения в staged-файлах относительно последних закоммиченных версий
```
git diff --staged
```
## Показать изменения в staged-файлах сравнивая коммиты
```
git diff b576d89 t536d84
```
## Посмотреть, что игнорируется, можно с помощью команды
```
git status --ignored
```
## Статусы

- Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус staged после выполнения git add.
- Статус modified означает, что файл был изменён.
```mermaid
graph LR;
  untracked -- "git add" --> staged;
  staged    -- "git commit -m "описание коммита"" --> tracked/comitted;
```
### Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

### Шпаргалка. Работа с ветками

## Клонирование чужого репозитория
```
git clone git@github.com:YandexPraktikum/first-project.git
```
(от англ. clone, «клон», «копия») — склонируй репозиторий с URL first-project.git из аккаунта YandexPraktikum на мой локальный компьютер.
## Создание веток
```
git branch feature/the-finest-branch
```
(от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch;
```
git checkout -b feature/the-finest-branch
```
— создай ветку feature/the-finest-branch и сразу переключись на неё.
## Навигация по веткам
```
git branch
```
(от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
```
git checkout feature/br
```
— переключись на ветку feature/br.
## Сравнение веток
```
git diff main HEAD
```
(от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD;
```
git diff HEAD~2 HEAD
```
— покажи разницу между тем коммитом, который был два коммита назад, и текущим.
## Удаление веток
```
git branch -d br-name
```
— удали ветку br-name, но только если она является частью main;
```
git branch -D br-name
```
— удали ветку br-name, даже если она не объединена с main.
## Слияние веток
```
git merge main
```
(от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой.
## Работа с удалённым репозиторием
```
git push -u origin my-branch
```
(от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u;
```
git push my-branch
```
— отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;
```
git pull
```
(от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.
## Командная работа в Git

Feature branch workflow

Самый популярный подход к работе с Git в команде — это feature branch workflow. В нём создают ветку для каждой задачи (например, для новой функциональности или исправления бага), а когда всё готово, вливают новую ветку в main. \
Важные этапы этого процесса — пул-реквест и ревью изменений. \
Пул-реквест — это интерфейс, в котором можно обсудить изменения. Ревью — просмотр изменений другими участниками и один из способов проверить качество таких изменений. \
Если вы уже участник проекта (или collaborator в терминах GitHub), можно клонировать репозиторий напрямую. А если нет, нужно предварительно сделать «форк». Также для участников доступна кнопка Merge после ревью, а для неучастников — нет.

## Конфликты слияния

Когда один и тот же файл меняется в нескольких ветках, при их слиянии может произойти конфликт. Пугаться конфликтов не нужно, это нормальная часть работы с системами контроля версий. IDE, вроде VSCode или Intellij IDEA, помогут «склеить» файл из двух конфликтующих версий.

## Алгоритм-шпаргалка для создания PR

- Склонировать репозиторий.
- Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.
- На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.
- Выполнить команду git clone <ссылка на репозиторий>.
- Создать ветку для вашей задачи: ``` git checkout -b my-task-branch-name ``` .
- Добавить и «закоммитить» изменения, которые вы хотите внести в проект.
- «Запушить» ветку: ``` git push --set-upstream origin HEAD ``` или ``` git push -u origin my-task-branch-name ``` .
- GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.
- PR можно также создать через интерфейс GitHub.
- Сообщить о пул-реквесте ревьюеру.
- Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.
- Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).
- Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью, нужно разрешить конфликт:
- Обновить main: ``` git checkout main && git pull ``` .
- Влить main в свою ветку: ``` git checkout my-task-branch-name && git merge main ``` .
- Разрешить конфликты слияния с помощью IDE или вручную.
- Создать коммит слияния: ``` git commit --no-edit ``` или ``` git commit -m 'merge main' ``` .
- Сделать ``` git push ``` своей ветки.
- Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.
- Ещё раз обновить main, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: ``` git checkout main && git pull ``` .

## Алгоритм-шпаргалка для разрешения конфликтов слияния

Открыть проект в IDE (VS Code, IDEA или другие). \
Открыть файл, в котором есть конфликт. \
Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой. \
Когда конфликты разрешены, сделать коммит: ``` git commit --no-edit ``` или ``` git commit -m 'merge branch <название ветки>' ``` .
